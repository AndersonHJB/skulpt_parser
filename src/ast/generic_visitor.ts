// Copyright (c) 2021 the Skulpt Project
// SPDX-License-Identifier: MIT

/* File automatically generated by gen_asdl/__main__.py. */
// deno-lint-ignore-file no-explicit-any

import { ASTVisitor } from "./visitor.ts";
import type {
    Module,
    Interactive,
    Expression,
    FunctionType,
    FunctionDef,
    AsyncFunctionDef,
    ClassDef,
    Return,
    Delete,
    Assign,
    AugAssign,
    AnnAssign,
    For,
    AsyncFor,
    While,
    If,
    With,
    AsyncWith,
    Raise,
    Try,
    Assert,
    Import,
    ImportFrom,
    Global,
    Nonlocal,
    Expr,
    Pass,
    Break,
    Continue,
    Debugger,
    BoolOp,
    NamedExpr,
    BinOp,
    UnaryOp,
    Lambda,
    IfExp,
    Dict,
    Set_,
    ListComp,
    SetComp,
    DictComp,
    GeneratorExp,
    Await,
    Yield,
    YieldFrom,
    Compare,
    Call,
    FormattedValue,
    JoinedStr,
    Constant,
    Attribute,
    Subscript,
    Starred,
    Name,
    List,
    Tuple,
    Slice,
    comprehension,
    ExceptHandler,
    arguments_,
    arg,
    keyword,
    alias,
    withitem,
    TypeIgnore,
} from "./astnodes.ts";

export abstract class GenericASTVisitor extends ASTVisitor {
    visit_Module(node: Module) {
        this.visitSeq(node.body);
        this.visitSeq(node.type_ignores);
    }
    visit_Interactive(node: Interactive) {
        this.visitSeq(node.body);
    }
    visit_Expression(node: Expression) {
        node.body.walkabout(this);
    }
    visit_FunctionType(node: FunctionType) {
        this.visitSeq(node.argtypes);
        node.returns.walkabout(this);
    }
    visit_FunctionDef(node: FunctionDef) {
        node.args.walkabout(this);
        this.visitSeq(node.body);
        this.visitSeq(node.decorator_list);
        if (node.returns) node.returns.walkabout(this);
    }
    visit_AsyncFunctionDef(node: AsyncFunctionDef) {
        node.args.walkabout(this);
        this.visitSeq(node.body);
        this.visitSeq(node.decorator_list);
        if (node.returns) node.returns.walkabout(this);
    }
    visit_ClassDef(node: ClassDef) {
        this.visitSeq(node.bases);
        this.visitSeq(node.keywords);
        this.visitSeq(node.body);
        this.visitSeq(node.decorator_list);
    }
    visit_Return(node: Return) {
        if (node.value) node.value.walkabout(this);
    }
    visit_Delete(node: Delete) {
        this.visitSeq(node.targets);
    }
    visit_Assign(node: Assign) {
        this.visitSeq(node.targets);
        node.value.walkabout(this);
    }
    visit_AugAssign(node: AugAssign) {
        node.target.walkabout(this);
        node.value.walkabout(this);
    }
    visit_AnnAssign(node: AnnAssign) {
        node.target.walkabout(this);
        node.annotation.walkabout(this);
        if (node.value) node.value.walkabout(this);
    }
    visit_For(node: For) {
        node.target.walkabout(this);
        node.iter.walkabout(this);
        this.visitSeq(node.body);
        this.visitSeq(node.orelse);
    }
    visit_AsyncFor(node: AsyncFor) {
        node.target.walkabout(this);
        node.iter.walkabout(this);
        this.visitSeq(node.body);
        this.visitSeq(node.orelse);
    }
    visit_While(node: While) {
        node.test.walkabout(this);
        this.visitSeq(node.body);
        this.visitSeq(node.orelse);
    }
    visit_If(node: If) {
        node.test.walkabout(this);
        this.visitSeq(node.body);
        this.visitSeq(node.orelse);
    }
    visit_With(node: With) {
        this.visitSeq(node.items);
        this.visitSeq(node.body);
    }
    visit_AsyncWith(node: AsyncWith) {
        this.visitSeq(node.items);
        this.visitSeq(node.body);
    }
    visit_Raise(node: Raise) {
        if (node.exc) node.exc.walkabout(this);
        if (node.cause) node.cause.walkabout(this);
    }
    visit_Try(node: Try) {
        this.visitSeq(node.body);
        this.visitSeq(node.handlers);
        this.visitSeq(node.orelse);
        this.visitSeq(node.finalbody);
    }
    visit_Assert(node: Assert) {
        node.test.walkabout(this);
        if (node.msg) node.msg.walkabout(this);
    }
    visit_Import(node: Import) {
        this.visitSeq(node.names);
    }
    visit_ImportFrom(node: ImportFrom) {
        this.visitSeq(node.names);
    }
    visit_Global(_node: Global) {}
    visit_Nonlocal(_node: Nonlocal) {}
    visit_Expr(node: Expr) {
        node.value.walkabout(this);
    }
    visit_Pass(_node: Pass) {}
    visit_Break(_node: Break) {}
    visit_Continue(_node: Continue) {}
    visit_Debugger(_node: Debugger) {}
    visit_BoolOp(node: BoolOp) {
        this.visitSeq(node.values);
    }
    visit_NamedExpr(node: NamedExpr) {
        node.target.walkabout(this);
        node.value.walkabout(this);
    }
    visit_BinOp(node: BinOp) {
        node.left.walkabout(this);
        node.right.walkabout(this);
    }
    visit_UnaryOp(node: UnaryOp) {
        node.operand.walkabout(this);
    }
    visit_Lambda(node: Lambda) {
        node.args.walkabout(this);
        node.body.walkabout(this);
    }
    visit_IfExp(node: IfExp) {
        node.test.walkabout(this);
        node.body.walkabout(this);
        node.orelse.walkabout(this);
    }
    visit_Dict(node: Dict) {
        this.visitSeq(node.keys);
        this.visitSeq(node.values);
    }
    visit_Set_(node: Set_) {
        this.visitSeq(node.elts);
    }
    visit_ListComp(node: ListComp) {
        node.elt.walkabout(this);
        this.visitSeq(node.generators);
    }
    visit_SetComp(node: SetComp) {
        node.elt.walkabout(this);
        this.visitSeq(node.generators);
    }
    visit_DictComp(node: DictComp) {
        node.key.walkabout(this);
        node.value.walkabout(this);
        this.visitSeq(node.generators);
    }
    visit_GeneratorExp(node: GeneratorExp) {
        node.elt.walkabout(this);
        this.visitSeq(node.generators);
    }
    visit_Await(node: Await) {
        node.value.walkabout(this);
    }
    visit_Yield(node: Yield) {
        if (node.value) node.value.walkabout(this);
    }
    visit_YieldFrom(node: YieldFrom) {
        node.value.walkabout(this);
    }
    visit_Compare(node: Compare) {
        node.left.walkabout(this);
        this.visitSeq(node.comparators);
    }
    visit_Call(node: Call) {
        node.func.walkabout(this);
        this.visitSeq(node.args);
        this.visitSeq(node.keywords);
    }
    visit_FormattedValue(node: FormattedValue) {
        node.value.walkabout(this);
        if (node.format_spec) node.format_spec.walkabout(this);
    }
    visit_JoinedStr(node: JoinedStr) {
        this.visitSeq(node.values);
    }
    visit_Constant(_node: Constant) {}
    visit_Attribute(node: Attribute) {
        node.value.walkabout(this);
    }
    visit_Subscript(node: Subscript) {
        node.value.walkabout(this);
        node.slice.walkabout(this);
    }
    visit_Starred(node: Starred) {
        node.value.walkabout(this);
    }
    visit_Name(_node: Name) {}
    visit_List(node: List) {
        this.visitSeq(node.elts);
    }
    visit_Tuple(node: Tuple) {
        this.visitSeq(node.elts);
    }
    visit_Slice(node: Slice) {
        if (node.lower) node.lower.walkabout(this);
        if (node.upper) node.upper.walkabout(this);
        if (node.step) node.step.walkabout(this);
    }
    visit_comprehension(node: comprehension) {
        node.target.walkabout(this);
        node.iter.walkabout(this);
        this.visitSeq(node.ifs);
    }
    visit_ExceptHandler(node: ExceptHandler) {
        if (node.type) node.type.walkabout(this);
        this.visitSeq(node.body);
    }
    visit_arguments_(node: arguments_) {
        this.visitSeq(node.posonlyargs);
        this.visitSeq(node.args);
        if (node.vararg) node.vararg.walkabout(this);
        this.visitSeq(node.kwonlyargs);
        this.visitSeq(node.kw_defaults);
        if (node.kwarg) node.kwarg.walkabout(this);
        this.visitSeq(node.defaults);
    }
    visit_arg(node: arg) {
        if (node.annotation) node.annotation.walkabout(this);
    }
    visit_keyword(node: keyword) {
        node.value.walkabout(this);
    }
    visit_alias(_node: alias) {}
    visit_withitem(node: withitem) {
        node.context_expr.walkabout(this);
        if (node.optional_vars) node.optional_vars.walkabout(this);
    }
    visit_TypeIgnore(_node: TypeIgnore) {}
}
