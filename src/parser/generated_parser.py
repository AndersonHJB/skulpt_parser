#!/usr/bin/env python3.8
# @generated by pegen from ../cpython/Grammar/python.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
class GeneratedParser(Parser):

    @memoize
    def file(self) -> Optional[mod_ty]:
        # file: statements? $
        mark = self.mark()
        cut = False
        if (
            (a := self.statements(),)
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return _PyPegen_make_module ( p , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def interactive(self) -> Optional[mod_ty]:
        # interactive: statement_newline
        mark = self.mark()
        cut = False
        if (
            (a := self.statement_newline())
        ):
            return Interactive ( a , p -> arena )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def eval(self) -> Optional[mod_ty]:
        # eval: expressions NEWLINE* $
        mark = self.mark()
        cut = False
        if (
            (a := self.expressions())
            and
            (_loop0_1 := self._loop0_1(),)
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return Expression ( a , p -> arena )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def func_type(self) -> Optional[mod_ty]:
        # func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.type_expressions(),)
            and
            (literal_1 := self.expect(')'))
            and
            (literal_2 := self.expect('->'))
            and
            (b := self.expression())
            and
            (_loop0_2 := self._loop0_2(),)
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return FunctionType ( a , b , p -> arena )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def fstring(self) -> Optional[expr_ty]:
        # fstring: star_expressions
        mark = self.mark()
        cut = False
        if (
            (star_expressions := self.star_expressions())
        ):
            return [star_expressions]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def type_expressions(self) -> Optional[asdl_seq*]:
        # type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_3())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('*'))
            and
            (b := self.expression())
            and
            (literal_2 := self.expect(','))
            and
            (literal_3 := self.expect('**'))
            and
            (c := self.expression())
        ):
            return _PyPegen_seq_append_to_end ( p , CHECK ( _PyPegen_seq_append_to_end ( p , a , b ) ) , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_5())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('*'))
            and
            (b := self.expression())
        ):
            return _PyPegen_seq_append_to_end ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_7())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('**'))
            and
            (b := self.expression())
        ):
            return _PyPegen_seq_append_to_end ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.expression())
            and
            (literal_1 := self.expect(','))
            and
            (literal_2 := self.expect('**'))
            and
            (b := self.expression())
        ):
            return _PyPegen_seq_append_to_end ( p , CHECK ( _PyPegen_singleton_seq ( p , a ) ) , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.expression())
        ):
            return _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (a := self.expression())
        ):
            return _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_gather_9 := self._gather_9())
        ):
            return [_gather_9]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statements(self) -> Optional[asdl_seq*]:
        # statements: statement+
        mark = self.mark()
        cut = False
        if (
            (a := self._loop1_11())
        ):
            return _PyPegen_seq_flatten ( p , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statement(self) -> Optional[asdl_seq*]:
        # statement: compound_stmt | simple_stmt
        mark = self.mark()
        cut = False
        if (
            (a := self.compound_stmt())
        ):
            return _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return [simple_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statement_newline(self) -> Optional[asdl_seq*]:
        # statement_newline: compound_stmt NEWLINE | simple_stmt | NEWLINE | $
        mark = self.mark()
        cut = False
        if (
            (a := self.compound_stmt())
            and
            (newline := self.expect('NEWLINE'))
        ):
            return _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return [simple_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
        ):
            return _PyPegen_singleton_seq ( p , CHECK ( _Py_Pass ( EXTRA ) ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (endmarker := self.expect('ENDMARKER'))
        ):
            return _PyPegen_interactive_exit ( p )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def simple_stmt(self) -> Optional[asdl_seq*]:
        # simple_stmt: small_stmt !';' NEWLINE | ';'.small_stmt+ ';'? NEWLINE
        mark = self.mark()
        cut = False
        if (
            (a := self.small_stmt())
            and
            self.negative_lookahead(self.expect, ';')
            and
            (newline := self.expect('NEWLINE'))
        ):
            return _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_12())
            and
            (opt := self.expect(';'),)
            and
            (newline := self.expect('NEWLINE'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def small_stmt(self) -> Optional[stmt_ty]:
        # small_stmt: assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
        mark = self.mark()
        cut = False
        if (
            (assignment := self.assignment())
        ):
            return [assignment]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (e := self.star_expressions())
        ):
            return _Py_Expr ( e , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'return')
            and
            (return_stmt := self.return_stmt())
        ):
            return [return_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_14, )
            and
            (import_stmt := self.import_stmt())
        ):
            return [import_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'raise')
            and
            (raise_stmt := self.raise_stmt())
        ):
            return [raise_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('pass'))
        ):
            return _Py_Pass ( EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'del')
            and
            (del_stmt := self.del_stmt())
        ):
            return [del_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'yield')
            and
            (yield_stmt := self.yield_stmt())
        ):
            return [yield_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'assert')
            and
            (assert_stmt := self.assert_stmt())
        ):
            return [assert_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('break'))
        ):
            return _Py_Break ( EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('continue'))
        ):
            return _Py_Continue ( EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'global')
            and
            (global_stmt := self.global_stmt())
        ):
            return [global_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'nonlocal')
            and
            (nonlocal_stmt := self.nonlocal_stmt())
        ):
            return [nonlocal_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def compound_stmt(self) -> Optional[stmt_ty]:
        # compound_stmt: &('def' | '@' | ASYNC) function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' | ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt
        mark = self.mark()
        cut = False
        if (
            self.positive_lookahead(self._tmp_15, )
            and
            (function_def := self.function_def())
        ):
            return [function_def]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'if')
            and
            (if_stmt := self.if_stmt())
        ):
            return [if_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_16, )
            and
            (class_def := self.class_def())
        ):
            return [class_def]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_17, )
            and
            (with_stmt := self.with_stmt())
        ):
            return [with_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_18, )
            and
            (for_stmt := self.for_stmt())
        ):
            return [for_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'try')
            and
            (try_stmt := self.try_stmt())
        ):
            return [try_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'while')
            and
            (while_stmt := self.while_stmt())
        ):
            return [while_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def assignment(self) -> Optional[stmt_ty]:
        # assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions) | invalid_assignment
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (literal := self.expect(':'))
            and
            (b := self.expression())
            and
            (c := self._tmp_19(),)
        ):
            return CHECK_VERSION ( 6 , "Variable annotation syntax is" , _Py_AnnAssign ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._tmp_20())
            and
            (literal := self.expect(':'))
            and
            (b := self.expression())
            and
            (c := self._tmp_21(),)
        ):
            return CHECK_VERSION ( 6 , "Variable annotations syntax is" , _Py_AnnAssign ( a , b , c , 0 , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_22())
            and
            (b := self._tmp_23())
            and
            self.negative_lookahead(self.expect, '=')
            and
            (tc := self.TYPE_COMMENT(),)
        ):
            return _Py_Assign ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.single_target())
            and
            (b := self.augassign())
            and
            (cut := True)
            and
            (c := self._tmp_24())
        ):
            return _Py_AugAssign ( a , b -> kind , c , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_assignment := self.invalid_assignment())
        ):
            return [invalid_assignment]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def augassign(self) -> Optional[AugOperator*]:
        # augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('+='))
        ):
            return _PyPegen_augoperator ( p , Add )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-='))
        ):
            return _PyPegen_augoperator ( p , Sub )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*='))
        ):
            return _PyPegen_augoperator ( p , Mult )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('@='))
        ):
            return CHECK_VERSION ( 5 , "The '@' operator is" , _PyPegen_augoperator ( p , MatMult ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('/='))
        ):
            return _PyPegen_augoperator ( p , Div )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('%='))
        ):
            return _PyPegen_augoperator ( p , Mod )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('&='))
        ):
            return _PyPegen_augoperator ( p , BitAnd )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('|='))
        ):
            return _PyPegen_augoperator ( p , BitOr )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('^='))
        ):
            return _PyPegen_augoperator ( p , BitXor )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('<<='))
        ):
            return _PyPegen_augoperator ( p , LShift )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>>='))
        ):
            return _PyPegen_augoperator ( p , RShift )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**='))
        ):
            return _PyPegen_augoperator ( p , Pow )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('//='))
        ):
            return _PyPegen_augoperator ( p , FloorDiv )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def global_stmt(self) -> Optional[stmt_ty]:
        # global_stmt: 'global' ','.NAME+
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('global'))
            and
            (a := self._gather_25())
        ):
            return _Py_Global ( CHECK ( _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def nonlocal_stmt(self) -> Optional[stmt_ty]:
        # nonlocal_stmt: 'nonlocal' ','.NAME+
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('nonlocal'))
            and
            (a := self._gather_27())
        ):
            return _Py_Nonlocal ( CHECK ( _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def yield_stmt(self) -> Optional[stmt_ty]:
        # yield_stmt: yield_expr
        mark = self.mark()
        cut = False
        if (
            (y := self.yield_expr())
        ):
            return _Py_Expr ( y , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def assert_stmt(self) -> Optional[stmt_ty]:
        # assert_stmt: 'assert' expression [',' expression]
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('assert'))
            and
            (a := self.expression())
            and
            (b := self._tmp_29(),)
        ):
            return _Py_Assert ( a , b , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def del_stmt(self) -> Optional[stmt_ty]:
        # del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('del'))
            and
            (a := self.del_targets())
            and
            self.positive_lookahead(self._tmp_30, )
        ):
            return _Py_Delete ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_del_stmt := self.invalid_del_stmt())
        ):
            return [invalid_del_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_stmt(self) -> Optional[stmt_ty]:
        # import_stmt: import_name | import_from
        mark = self.mark()
        cut = False
        if (
            (import_name := self.import_name())
        ):
            return [import_name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_from := self.import_from())
        ):
            return [import_from]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_name(self) -> Optional[stmt_ty]:
        # import_name: 'import' dotted_as_names
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('import'))
            and
            (a := self.dotted_as_names())
        ):
            return _Py_Import ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from(self) -> Optional[stmt_ty]:
        # import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (a := self._loop0_31(),)
            and
            (b := self.dotted_name())
            and
            (literal_1 := self.expect('import'))
            and
            (c := self.import_from_targets())
        ):
            return _Py_ImportFrom ( b -> v . Name . id , c , _PyPegen_seq_count_dots ( a ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (a := self._loop1_32())
            and
            (literal_1 := self.expect('import'))
            and
            (b := self.import_from_targets())
        ):
            return _Py_ImportFrom ( NULL , b , _PyPegen_seq_count_dots ( a ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from_targets(self) -> Optional[asdl_seq*]:
        # import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*' | invalid_import_from_targets
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.import_from_as_names())
            and
            (opt := self.expect(','),)
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_from_as_names := self.import_from_as_names())
            and
            self.negative_lookahead(self.expect, ',')
        ):
            return [import_from_as_names]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
        ):
            return _PyPegen_singleton_seq ( p , CHECK ( _PyPegen_alias_for_star ( p ) ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_import_from_targets := self.invalid_import_from_targets())
        ):
            return [invalid_import_from_targets]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from_as_names(self) -> Optional[asdl_seq*]:
        # import_from_as_names: ','.import_from_as_name+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_33())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from_as_name(self) -> Optional[alias_ty]:
        # import_from_as_name: NAME ['as' NAME]
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (b := self._tmp_35(),)
        ):
            return _Py_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , p -> arena )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dotted_as_names(self) -> Optional[asdl_seq*]:
        # dotted_as_names: ','.dotted_as_name+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_36())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dotted_as_name(self) -> Optional[alias_ty]:
        # dotted_as_name: dotted_name ['as' NAME]
        mark = self.mark()
        cut = False
        if (
            (a := self.dotted_name())
            and
            (b := self._tmp_38(),)
        ):
            return _Py_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , p -> arena )
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def dotted_name(self) -> Optional[expr_ty]:
        # dotted_name: dotted_name '.' NAME | NAME
        mark = self.mark()
        cut = False
        if (
            (a := self.dotted_name())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
        ):
            return _PyPegen_join_names_with_dot ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def if_stmt(self) -> Optional[stmt_ty]:
        # if_stmt: 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.elif_stmt())
        ):
            return _Py_If ( a , b , CHECK ( _PyPegen_singleton_seq ( p , c ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.else_block(),)
        ):
            return _Py_If ( a , b , c , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def elif_stmt(self) -> Optional[stmt_ty]:
        # elif_stmt: 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('elif'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.elif_stmt())
        ):
            return _Py_If ( a , b , CHECK ( _PyPegen_singleton_seq ( p , c ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('elif'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.else_block(),)
        ):
            return _Py_If ( a , b , c , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def else_block(self) -> Optional[asdl_seq*]:
        # else_block: 'else' ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
        ):
            return b
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def while_stmt(self) -> Optional[stmt_ty]:
        # while_stmt: 'while' named_expression ':' block else_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('while'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.else_block(),)
        ):
            return _Py_While ( a , b , c , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def for_stmt(self) -> Optional[stmt_ty]:
        # for_stmt: 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | invalid_for_target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('for'))
            and
            (t := self.star_targets())
            and
            (literal_1 := self.expect('in'))
            and
            (cut := True)
            and
            (ex := self.star_expressions())
            and
            (literal_2 := self.expect(':'))
            and
            (tc := self.TYPE_COMMENT(),)
            and
            (b := self.block())
            and
            (el := self.else_block(),)
        ):
            return _Py_For ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (async := self.expect('ASYNC'))
            and
            (literal := self.expect('for'))
            and
            (t := self.star_targets())
            and
            (literal_1 := self.expect('in'))
            and
            (cut := True)
            and
            (ex := self.star_expressions())
            and
            (literal_2 := self.expect(':'))
            and
            (tc := self.TYPE_COMMENT(),)
            and
            (b := self.block())
            and
            (el := self.else_block(),)
        ):
            return CHECK_VERSION ( 5 , "Async for loops are" , _Py_AsyncFor ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_for_target := self.invalid_for_target())
        ):
            return [invalid_for_target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def with_stmt(self) -> Optional[stmt_ty]:
        # with_stmt: 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' TYPE_COMMENT? block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('with'))
            and
            (literal_1 := self.expect('('))
            and
            (a := self._gather_39())
            and
            (opt := self.expect(','),)
            and
            (literal_2 := self.expect(')'))
            and
            (literal_3 := self.expect(':'))
            and
            (b := self.block())
        ):
            return _Py_With ( a , b , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('with'))
            and
            (a := self._gather_41())
            and
            (literal_1 := self.expect(':'))
            and
            (tc := self.TYPE_COMMENT(),)
            and
            (b := self.block())
        ):
            return _Py_With ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (async := self.expect('ASYNC'))
            and
            (literal := self.expect('with'))
            and
            (literal_1 := self.expect('('))
            and
            (a := self._gather_43())
            and
            (opt := self.expect(','),)
            and
            (literal_2 := self.expect(')'))
            and
            (literal_3 := self.expect(':'))
            and
            (b := self.block())
        ):
            return CHECK_VERSION ( 5 , "Async with statements are" , _Py_AsyncWith ( a , b , NULL , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (async := self.expect('ASYNC'))
            and
            (literal := self.expect('with'))
            and
            (a := self._gather_45())
            and
            (literal_1 := self.expect(':'))
            and
            (tc := self.TYPE_COMMENT(),)
            and
            (b := self.block())
        ):
            return CHECK_VERSION ( 5 , "Async with statements are" , _Py_AsyncWith ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def with_item(self) -> Optional[withitem_ty]:
        # with_item: expression 'as' star_target &(',' | ')' | ':') | invalid_with_item | expression
        mark = self.mark()
        cut = False
        if (
            (e := self.expression())
            and
            (literal := self.expect('as'))
            and
            (t := self.star_target())
            and
            self.positive_lookahead(self._tmp_47, )
        ):
            return _Py_withitem ( e , t , p -> arena )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_with_item := self.invalid_with_item())
        ):
            return [invalid_with_item]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (e := self.expression())
        ):
            return _Py_withitem ( e , NULL , p -> arena )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def try_stmt(self) -> Optional[stmt_ty]:
        # try_stmt: 'try' ':' block finally_block | 'try' ':' block except_block+ else_block? finally_block?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('try'))
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (f := self.finally_block())
        ):
            return _Py_Try ( b , NULL , NULL , f , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('try'))
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (ex := self._loop1_48())
            and
            (el := self.else_block(),)
            and
            (f := self.finally_block(),)
        ):
            return _Py_Try ( b , ex , el , f , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def except_block(self) -> Optional[excepthandler_ty]:
        # except_block: 'except' expression ['as' NAME] ':' block | 'except' ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('except'))
            and
            (e := self.expression())
            and
            (t := self._tmp_49(),)
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
        ):
            return _Py_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('except'))
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
        ):
            return _Py_ExceptHandler ( NULL , NULL , b , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def finally_block(self) -> Optional[asdl_seq*]:
        # finally_block: 'finally' ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('finally'))
            and
            (literal_1 := self.expect(':'))
            and
            (a := self.block())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def return_stmt(self) -> Optional[stmt_ty]:
        # return_stmt: 'return' star_expressions?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('return'))
            and
            (a := self.star_expressions(),)
        ):
            return _Py_Return ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def raise_stmt(self) -> Optional[stmt_ty]:
        # raise_stmt: 'raise' expression ['from' expression] | 'raise'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('raise'))
            and
            (a := self.expression())
            and
            (b := self._tmp_50(),)
        ):
            return _Py_Raise ( a , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('raise'))
        ):
            return _Py_Raise ( NULL , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def function_def(self) -> Optional[stmt_ty]:
        # function_def: decorators function_def_raw | function_def_raw
        mark = self.mark()
        cut = False
        if (
            (d := self.decorators())
            and
            (f := self.function_def_raw())
        ):
            return _PyPegen_function_def_decorators ( p , d , f )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (function_def_raw := self.function_def_raw())
        ):
            return [function_def_raw]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def function_def_raw(self) -> Optional[stmt_ty]:
        # function_def_raw: 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block | ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('def'))
            and
            (n := self.name())
            and
            (literal_1 := self.expect('('))
            and
            (params := self.params(),)
            and
            (literal_2 := self.expect(')'))
            and
            (a := self._tmp_51(),)
            and
            (literal_3 := self.expect(':'))
            and
            (tc := self.func_type_comment(),)
            and
            (b := self.block())
        ):
            return _Py_FunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (async := self.expect('ASYNC'))
            and
            (literal := self.expect('def'))
            and
            (n := self.name())
            and
            (literal_1 := self.expect('('))
            and
            (params := self.params(),)
            and
            (literal_2 := self.expect(')'))
            and
            (a := self._tmp_52(),)
            and
            (literal_3 := self.expect(':'))
            and
            (tc := self.func_type_comment(),)
            and
            (b := self.block())
        ):
            return CHECK_VERSION ( 5 , "Async functions are" , _Py_AsyncFunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def func_type_comment(self) -> Optional[Token*]:
        # func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | invalid_double_type_comments | TYPE_COMMENT
        mark = self.mark()
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
            and
            (t := self.TYPE_COMMENT())
            and
            self.positive_lookahead(self._tmp_53, )
        ):
            return t
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_double_type_comments := self.invalid_double_type_comments())
        ):
            return [invalid_double_type_comments]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (TYPE_COMMENT := self.TYPE_COMMENT())
        ):
            return [TYPE_COMMENT]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def params(self) -> Optional[arguments_ty]:
        # params: invalid_parameters | parameters
        mark = self.mark()
        cut = False
        if (
            (invalid_parameters := self.invalid_parameters())
        ):
            return [invalid_parameters]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (parameters := self.parameters())
        ):
            return [parameters]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def parameters(self) -> Optional[arguments_ty]:
        # parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
        mark = self.mark()
        cut = False
        if (
            (a := self.slash_no_default())
            and
            (b := self._loop0_54(),)
            and
            (c := self._loop0_55(),)
            and
            (d := self.star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , a , NULL , b , c , d )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.slash_with_default())
            and
            (b := self._loop0_56(),)
            and
            (c := self.star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , NULL , a , NULL , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_57())
            and
            (b := self._loop0_58(),)
            and
            (c := self.star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , NULL , NULL , a , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_59())
            and
            (b := self.star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.star_etc())
        ):
            return _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slash_no_default(self) -> Optional[asdl_seq*]:
        # slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
        mark = self.mark()
        cut = False
        if (
            (a := self._loop1_60())
            and
            (literal := self.expect('/'))
            and
            (literal_1 := self.expect(','))
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_61())
            and
            (literal := self.expect('/'))
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slash_with_default(self) -> Optional[SlashWithDefault*]:
        # slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
        mark = self.mark()
        cut = False
        if (
            (a := self._loop0_62(),)
            and
            (b := self._loop1_63())
            and
            (literal := self.expect('/'))
            and
            (literal_1 := self.expect(','))
        ):
            return _PyPegen_slash_with_default ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop0_64(),)
            and
            (b := self._loop1_65())
            and
            (literal := self.expect('/'))
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return _PyPegen_slash_with_default ( p , a , b )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_etc(self) -> Optional[StarEtc*]:
        # star_etc: '*' param_no_default param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds | invalid_star_etc
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.param_no_default())
            and
            (b := self._loop0_66(),)
            and
            (c := self.kwds(),)
        ):
            return _PyPegen_star_etc ( p , a , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (literal_1 := self.expect(','))
            and
            (b := self._loop1_67())
            and
            (c := self.kwds(),)
        ):
            return _PyPegen_star_etc ( p , NULL , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.kwds())
        ):
            return _PyPegen_star_etc ( p , NULL , NULL , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_star_etc := self.invalid_star_etc())
        ):
            return [invalid_star_etc]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwds(self) -> Optional[arg_ty]:
        # kwds: '**' param_no_default
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (a := self.param_no_default())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def param_no_default(self) -> Optional[arg_ty]:
        # param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
        mark = self.mark()
        cut = False
        if (
            (a := self.param())
            and
            (literal := self.expect(','))
            and
            (tc := self.TYPE_COMMENT(),)
        ):
            return _PyPegen_add_type_comment_to_arg ( p , a , tc )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.param())
            and
            (tc := self.TYPE_COMMENT(),)
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return _PyPegen_add_type_comment_to_arg ( p , a , tc )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def param_with_default(self) -> Optional[NameDefaultPair*]:
        # param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
        mark = self.mark()
        cut = False
        if (
            (a := self.param())
            and
            (c := self.default())
            and
            (literal := self.expect(','))
            and
            (tc := self.TYPE_COMMENT(),)
        ):
            return _PyPegen_name_default_pair ( p , a , c , tc )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.param())
            and
            (c := self.default())
            and
            (tc := self.TYPE_COMMENT(),)
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return _PyPegen_name_default_pair ( p , a , c , tc )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def param_maybe_default(self) -> Optional[NameDefaultPair*]:
        # param_maybe_default: param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'
        mark = self.mark()
        cut = False
        if (
            (a := self.param())
            and
            (c := self.default(),)
            and
            (literal := self.expect(','))
            and
            (tc := self.TYPE_COMMENT(),)
        ):
            return _PyPegen_name_default_pair ( p , a , c , tc )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.param())
            and
            (c := self.default(),)
            and
            (tc := self.TYPE_COMMENT(),)
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return _PyPegen_name_default_pair ( p , a , c , tc )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def param(self) -> Optional[arg_ty]:
        # param: NAME annotation?
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (b := self.annotation(),)
        ):
            return _Py_arg ( a -> v . Name . id , b , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def annotation(self) -> Optional[expr_ty]:
        # annotation: ':' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(':'))
            and
            (a := self.expression())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def default(self) -> Optional[expr_ty]:
        # default: '=' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('='))
            and
            (a := self.expression())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def decorators(self) -> Optional[asdl_seq*]:
        # decorators: (('@' named_expression NEWLINE))+
        mark = self.mark()
        cut = False
        if (
            (a := self._loop1_68())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def class_def(self) -> Optional[stmt_ty]:
        # class_def: decorators class_def_raw | class_def_raw
        mark = self.mark()
        cut = False
        if (
            (a := self.decorators())
            and
            (b := self.class_def_raw())
        ):
            return _PyPegen_class_def_decorators ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (class_def_raw := self.class_def_raw())
        ):
            return [class_def_raw]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def class_def_raw(self) -> Optional[stmt_ty]:
        # class_def_raw: 'class' NAME ['(' arguments? ')'] ':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('class'))
            and
            (a := self.name())
            and
            (b := self._tmp_69(),)
            and
            (literal_1 := self.expect(':'))
            and
            (c := self.block())
        ):
            return _Py_ClassDef ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , c , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def block(self) -> Optional[asdl_seq*]:
        # block: NEWLINE INDENT statements DEDENT | simple_stmt | invalid_block
        mark = self.mark()
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
            and
            (indent := self.expect('INDENT'))
            and
            (a := self.statements())
            and
            (dedent := self.expect('DEDENT'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return [simple_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_block := self.invalid_block())
        ):
            return [invalid_block]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_expressions(self) -> Optional[expr_ty]:
        # star_expressions: star_expression ((',' star_expression))+ ','? | star_expression ',' | star_expression
        mark = self.mark()
        cut = False
        if (
            (a := self.star_expression())
            and
            (b := self._loop1_70())
            and
            (opt := self.expect(','),)
        ):
            return _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.star_expression())
            and
            (literal := self.expect(','))
        ):
            return _Py_Tuple ( CHECK ( _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_expression := self.star_expression())
        ):
            return [star_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_expression(self) -> Optional[expr_ty]:
        # star_expression: '*' bitwise_or | expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.bitwise_or())
        ):
            return _Py_Starred ( a , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_named_expressions(self) -> Optional[asdl_seq*]:
        # star_named_expressions: ','.star_named_expression+ ','?
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_71())
            and
            (opt := self.expect(','),)
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_named_expression(self) -> Optional[expr_ty]:
        # star_named_expression: '*' bitwise_or | named_expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.bitwise_or())
        ):
            return _Py_Starred ( a , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (named_expression := self.named_expression())
        ):
            return [named_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def named_expression(self) -> Optional[expr_ty]:
        # named_expression: NAME ':=' ~ expression | expression !':=' | invalid_named_expression
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (literal := self.expect(':='))
            and
            (cut := True)
            and
            (b := self.expression())
        ):
            return _Py_NamedExpr ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
            and
            self.negative_lookahead(self.expect, ':=')
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_named_expression := self.invalid_named_expression())
        ):
            return [invalid_named_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def annotated_rhs(self) -> Optional[expr_ty]:
        # annotated_rhs: yield_expr | star_expressions
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_expressions := self.star_expressions())
        ):
            return [star_expressions]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def expressions(self) -> Optional[expr_ty]:
        # expressions: expression ((',' expression))+ ','? | expression ',' | expression
        mark = self.mark()
        cut = False
        if (
            (a := self.expression())
            and
            (b := self._loop1_73())
            and
            (opt := self.expect(','),)
        ):
            return _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.expression())
            and
            (literal := self.expect(','))
        ):
            return _Py_Tuple ( CHECK ( _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
        ):
            return [expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def expression(self) -> Optional[expr_ty]:
        # expression: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        mark = self.mark()
        cut = False
        if (
            (a := self.disjunction())
            and
            (literal := self.expect('if'))
            and
            (b := self.disjunction())
            and
            (literal_1 := self.expect('else'))
            and
            (c := self.expression())
        ):
            return _Py_IfExp ( b , a , c , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (disjunction := self.disjunction())
        ):
            return [disjunction]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (lambdef := self.lambdef())
        ):
            return [lambdef]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambdef(self) -> Optional[expr_ty]:
        # lambdef: 'lambda' lambda_params? ':' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('lambda'))
            and
            (a := self.lambda_params(),)
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.expression())
        ):
            return _Py_Lambda ( ( a ) ? a : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_params(self) -> Optional[arguments_ty]:
        # lambda_params: invalid_lambda_parameters | lambda_parameters
        mark = self.mark()
        cut = False
        if (
            (invalid_lambda_parameters := self.invalid_lambda_parameters())
        ):
            return [invalid_lambda_parameters]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (lambda_parameters := self.lambda_parameters())
        ):
            return [lambda_parameters]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_parameters(self) -> Optional[arguments_ty]:
        # lambda_parameters: lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc? | lambda_slash_with_default lambda_param_with_default* lambda_star_etc? | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc? | lambda_param_with_default+ lambda_star_etc? | lambda_star_etc
        mark = self.mark()
        cut = False
        if (
            (a := self.lambda_slash_no_default())
            and
            (b := self._loop0_74(),)
            and
            (c := self._loop0_75(),)
            and
            (d := self.lambda_star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , a , NULL , b , c , d )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.lambda_slash_with_default())
            and
            (b := self._loop0_76(),)
            and
            (c := self.lambda_star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , NULL , a , NULL , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_77())
            and
            (b := self._loop0_78(),)
            and
            (c := self.lambda_star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , NULL , NULL , a , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_79())
            and
            (b := self.lambda_star_etc(),)
        ):
            return _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.lambda_star_etc())
        ):
            return _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_slash_no_default(self) -> Optional[asdl_seq*]:
        # lambda_slash_no_default: lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'
        mark = self.mark()
        cut = False
        if (
            (a := self._loop1_80())
            and
            (literal := self.expect('/'))
            and
            (literal_1 := self.expect(','))
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_81())
            and
            (literal := self.expect('/'))
            and
            self.positive_lookahead(self.expect, ':')
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_slash_with_default(self) -> Optional[SlashWithDefault*]:
        # lambda_slash_with_default: lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'
        mark = self.mark()
        cut = False
        if (
            (a := self._loop0_82(),)
            and
            (b := self._loop1_83())
            and
            (literal := self.expect('/'))
            and
            (literal_1 := self.expect(','))
        ):
            return _PyPegen_slash_with_default ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop0_84(),)
            and
            (b := self._loop1_85())
            and
            (literal := self.expect('/'))
            and
            self.positive_lookahead(self.expect, ':')
        ):
            return _PyPegen_slash_with_default ( p , a , b )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_star_etc(self) -> Optional[StarEtc*]:
        # lambda_star_etc: '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds? | '*' ',' lambda_param_maybe_default+ lambda_kwds? | lambda_kwds | invalid_lambda_star_etc
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.lambda_param_no_default())
            and
            (b := self._loop0_86(),)
            and
            (c := self.lambda_kwds(),)
        ):
            return _PyPegen_star_etc ( p , a , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (literal_1 := self.expect(','))
            and
            (b := self._loop1_87())
            and
            (c := self.lambda_kwds(),)
        ):
            return _PyPegen_star_etc ( p , NULL , b , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.lambda_kwds())
        ):
            return _PyPegen_star_etc ( p , NULL , NULL , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_lambda_star_etc := self.invalid_lambda_star_etc())
        ):
            return [invalid_lambda_star_etc]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_kwds(self) -> Optional[arg_ty]:
        # lambda_kwds: '**' lambda_param_no_default
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (a := self.lambda_param_no_default())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_param_no_default(self) -> Optional[arg_ty]:
        # lambda_param_no_default: lambda_param ',' | lambda_param &':'
        mark = self.mark()
        cut = False
        if (
            (a := self.lambda_param())
            and
            (literal := self.expect(','))
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.lambda_param())
            and
            self.positive_lookahead(self.expect, ':')
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_param_with_default(self) -> Optional[NameDefaultPair*]:
        # lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
        mark = self.mark()
        cut = False
        if (
            (a := self.lambda_param())
            and
            (c := self.default())
            and
            (literal := self.expect(','))
        ):
            return _PyPegen_name_default_pair ( p , a , c , NULL )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.lambda_param())
            and
            (c := self.default())
            and
            self.positive_lookahead(self.expect, ':')
        ):
            return _PyPegen_name_default_pair ( p , a , c , NULL )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_param_maybe_default(self) -> Optional[NameDefaultPair*]:
        # lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
        mark = self.mark()
        cut = False
        if (
            (a := self.lambda_param())
            and
            (c := self.default(),)
            and
            (literal := self.expect(','))
        ):
            return _PyPegen_name_default_pair ( p , a , c , NULL )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.lambda_param())
            and
            (c := self.default(),)
            and
            self.positive_lookahead(self.expect, ':')
        ):
            return _PyPegen_name_default_pair ( p , a , c , NULL )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lambda_param(self) -> Optional[arg_ty]:
        # lambda_param: NAME
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
        ):
            return _Py_arg ( a -> v . Name . id , NULL , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def disjunction(self) -> Optional[expr_ty]:
        # disjunction: conjunction (('or' conjunction))+ | conjunction
        mark = self.mark()
        cut = False
        if (
            (a := self.conjunction())
            and
            (b := self._loop1_88())
        ):
            return _Py_BoolOp ( Or , CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (conjunction := self.conjunction())
        ):
            return [conjunction]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def conjunction(self) -> Optional[expr_ty]:
        # conjunction: inversion (('and' inversion))+ | inversion
        mark = self.mark()
        cut = False
        if (
            (a := self.inversion())
            and
            (b := self._loop1_89())
        ):
            return _Py_BoolOp ( And , CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (inversion := self.inversion())
        ):
            return [inversion]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def inversion(self) -> Optional[expr_ty]:
        # inversion: 'not' inversion | comparison
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('not'))
            and
            (a := self.inversion())
        ):
            return _Py_UnaryOp ( Not , a , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (comparison := self.comparison())
        ):
            return [comparison]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def comparison(self) -> Optional[expr_ty]:
        # comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        mark = self.mark()
        cut = False
        if (
            (a := self.bitwise_or())
            and
            (b := self._loop1_90())
        ):
            return _Py_Compare ( a , CHECK ( _PyPegen_get_cmpops ( p , b ) ) , CHECK ( _PyPegen_get_exprs ( p , b ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (bitwise_or := self.bitwise_or())
        ):
            return [bitwise_or]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def compare_op_bitwise_or_pair(self) -> Optional[CmpopExprPair*]:
        # compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or
        mark = self.mark()
        cut = False
        if (
            (eq_bitwise_or := self.eq_bitwise_or())
        ):
            return [eq_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (noteq_bitwise_or := self.noteq_bitwise_or())
        ):
            return [noteq_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (lte_bitwise_or := self.lte_bitwise_or())
        ):
            return [lte_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (lt_bitwise_or := self.lt_bitwise_or())
        ):
            return [lt_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (gte_bitwise_or := self.gte_bitwise_or())
        ):
            return [gte_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (gt_bitwise_or := self.gt_bitwise_or())
        ):
            return [gt_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (notin_bitwise_or := self.notin_bitwise_or())
        ):
            return [notin_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (in_bitwise_or := self.in_bitwise_or())
        ):
            return [in_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (isnot_bitwise_or := self.isnot_bitwise_or())
        ):
            return [isnot_bitwise_or]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (is_bitwise_or := self.is_bitwise_or())
        ):
            return [is_bitwise_or]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def eq_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # eq_bitwise_or: '==' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('=='))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , Eq , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def noteq_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # noteq_bitwise_or: ('!=') bitwise_or
        mark = self.mark()
        cut = False
        if (
            (tok := self.expect('!='))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , NotEq , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lte_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # lte_bitwise_or: '<=' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('<='))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , LtE , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lt_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # lt_bitwise_or: '<' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('<'))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , Lt , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def gte_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # gte_bitwise_or: '>=' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('>='))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , GtE , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def gt_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # gt_bitwise_or: '>' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('>'))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , Gt , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def notin_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # notin_bitwise_or: 'not' 'in' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('not'))
            and
            (literal_1 := self.expect('in'))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , NotIn , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def in_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # in_bitwise_or: 'in' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('in'))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , In , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def isnot_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # isnot_bitwise_or: 'is' 'not' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('is'))
            and
            (literal_1 := self.expect('not'))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , IsNot , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def is_bitwise_or(self) -> Optional[CmpopExprPair*]:
        # is_bitwise_or: 'is' bitwise_or
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('is'))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_cmpop_expr_pair ( p , Is , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def bitwise_or(self) -> Optional[expr_ty]:
        # bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        mark = self.mark()
        cut = False
        if (
            (a := self.bitwise_or())
            and
            (literal := self.expect('|'))
            and
            (b := self.bitwise_xor())
        ):
            return _Py_BinOp ( a , BitOr , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (bitwise_xor := self.bitwise_xor())
        ):
            return [bitwise_xor]
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def bitwise_xor(self) -> Optional[expr_ty]:
        # bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        mark = self.mark()
        cut = False
        if (
            (a := self.bitwise_xor())
            and
            (literal := self.expect('^'))
            and
            (b := self.bitwise_and())
        ):
            return _Py_BinOp ( a , BitXor , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (bitwise_and := self.bitwise_and())
        ):
            return [bitwise_and]
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def bitwise_and(self) -> Optional[expr_ty]:
        # bitwise_and: bitwise_and '&' shift_expr | shift_expr
        mark = self.mark()
        cut = False
        if (
            (a := self.bitwise_and())
            and
            (literal := self.expect('&'))
            and
            (b := self.shift_expr())
        ):
            return _Py_BinOp ( a , BitAnd , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (shift_expr := self.shift_expr())
        ):
            return [shift_expr]
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def shift_expr(self) -> Optional[expr_ty]:
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        mark = self.mark()
        cut = False
        if (
            (a := self.shift_expr())
            and
            (literal := self.expect('<<'))
            and
            (b := self.sum())
        ):
            return _Py_BinOp ( a , LShift , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.shift_expr())
            and
            (literal := self.expect('>>'))
            and
            (b := self.sum())
        ):
            return _Py_BinOp ( a , RShift , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (sum := self.sum())
        ):
            return [sum]
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def sum(self) -> Optional[expr_ty]:
        # sum: sum '+' term | sum '-' term | term
        mark = self.mark()
        cut = False
        if (
            (a := self.sum())
            and
            (literal := self.expect('+'))
            and
            (b := self.term())
        ):
            return _Py_BinOp ( a , Add , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.sum())
            and
            (literal := self.expect('-'))
            and
            (b := self.term())
        ):
            return _Py_BinOp ( a , Sub , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (term := self.term())
        ):
            return [term]
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def term(self) -> Optional[expr_ty]:
        # term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        mark = self.mark()
        cut = False
        if (
            (a := self.term())
            and
            (literal := self.expect('*'))
            and
            (b := self.factor())
        ):
            return _Py_BinOp ( a , Mult , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.term())
            and
            (literal := self.expect('/'))
            and
            (b := self.factor())
        ):
            return _Py_BinOp ( a , Div , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.term())
            and
            (literal := self.expect('//'))
            and
            (b := self.factor())
        ):
            return _Py_BinOp ( a , FloorDiv , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.term())
            and
            (literal := self.expect('%'))
            and
            (b := self.factor())
        ):
            return _Py_BinOp ( a , Mod , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.term())
            and
            (literal := self.expect('@'))
            and
            (b := self.factor())
        ):
            return CHECK_VERSION ( 5 , "The '@' operator is" , _Py_BinOp ( a , MatMult , b , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (factor := self.factor())
        ):
            return [factor]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def factor(self) -> Optional[expr_ty]:
        # factor: '+' factor | '-' factor | '~' factor | power
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('+'))
            and
            (a := self.factor())
        ):
            return _Py_UnaryOp ( UAdd , a , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-'))
            and
            (a := self.factor())
        ):
            return _Py_UnaryOp ( USub , a , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('~'))
            and
            (a := self.factor())
        ):
            return _Py_UnaryOp ( Invert , a , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (power := self.power())
        ):
            return [power]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def power(self) -> Optional[expr_ty]:
        # power: await_primary '**' factor | await_primary
        mark = self.mark()
        cut = False
        if (
            (a := self.await_primary())
            and
            (literal := self.expect('**'))
            and
            (b := self.factor())
        ):
            return _Py_BinOp ( a , Pow , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (await_primary := self.await_primary())
        ):
            return [await_primary]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def await_primary(self) -> Optional[expr_ty]:
        # await_primary: AWAIT primary | primary
        mark = self.mark()
        cut = False
        if (
            (await := self.expect('AWAIT'))
            and
            (a := self.primary())
        ):
            return CHECK_VERSION ( 5 , "Await expressions are" , _Py_Await ( a , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (primary := self.primary())
        ):
            return [primary]
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def primary(self) -> Optional[expr_ty]:
        # primary: invalid_primary | primary '.' NAME | primary genexp | primary '(' arguments? ')' | primary '[' slices ']' | atom
        mark = self.mark()
        cut = False
        if (
            (invalid_primary := self.invalid_primary())
        ):
            return [invalid_primary]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
        ):
            return _Py_Attribute ( a , b -> v . Name . id , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.primary())
            and
            (b := self.genexp())
        ):
            return _Py_Call ( a , CHECK ( _PyPegen_singleton_seq ( p , b ) ) , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.primary())
            and
            (literal := self.expect('('))
            and
            (b := self.arguments(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return _Py_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.primary())
            and
            (literal := self.expect('['))
            and
            (b := self.slices())
            and
            (literal_1 := self.expect(']'))
        ):
            return _Py_Subscript ( a , b , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (atom := self.atom())
        ):
            return [atom]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slices(self) -> Optional[expr_ty]:
        # slices: slice !',' | ','.slice+ ','?
        mark = self.mark()
        cut = False
        if (
            (a := self.slice())
            and
            self.negative_lookahead(self.expect, ',')
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_91())
            and
            (opt := self.expect(','),)
        ):
            return _Py_Tuple ( a , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def slice(self) -> Optional[expr_ty]:
        # slice: expression? ':' expression? [':' expression?] | expression
        mark = self.mark()
        cut = False
        if (
            (a := self.expression(),)
            and
            (literal := self.expect(':'))
            and
            (b := self.expression(),)
            and
            (c := self._tmp_93(),)
        ):
            return _Py_Slice ( a , b , c , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.expression())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def atom(self) -> Optional[expr_ty]:
        # atom: NAME | 'True' | 'False' | 'None' | '__peg_parser__' | &STRING strings | NUMBER | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | '...'
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('True'))
        ):
            return _Py_Constant ( Py_True , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('False'))
        ):
            return _Py_Constant ( Py_False , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('None'))
        ):
            return _Py_Constant ( Py_None , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('__peg_parser__'))
        ):
            return RAISE_SYNTAX_ERROR ( "You found it!" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.string, )
            and
            (strings := self.strings())
        ):
            return [strings]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (number := self.number())
        ):
            return [number]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, '(')
            and
            (_tmp_94 := self._tmp_94())
        ):
            return [_tmp_94]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, '[')
            and
            (_tmp_95 := self._tmp_95())
        ):
            return [_tmp_95]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, '{')
            and
            (_tmp_96 := self._tmp_96())
        ):
            return [_tmp_96]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('...'))
        ):
            return _Py_Constant ( Py_Ellipsis , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def strings(self) -> Optional[expr_ty]:
        # strings: STRING+
        mark = self.mark()
        cut = False
        if (
            (a := self._loop1_97())
        ):
            return _PyPegen_concatenate_strings ( p , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def list(self) -> Optional[expr_ty]:
        # list: '[' star_named_expressions? ']'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('['))
            and
            (a := self.star_named_expressions(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return _Py_List ( a , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def listcomp(self) -> Optional[expr_ty]:
        # listcomp: '[' named_expression ~ for_if_clauses ']' | invalid_comprehension
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('['))
            and
            (a := self.named_expression())
            and
            (cut := True)
            and
            (b := self.for_if_clauses())
            and
            (literal_1 := self.expect(']'))
        ):
            return _Py_ListComp ( a , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_comprehension := self.invalid_comprehension())
        ):
            return [invalid_comprehension]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def tuple(self) -> Optional[expr_ty]:
        # tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self._tmp_98(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return _Py_Tuple ( a , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def group(self) -> Optional[expr_ty]:
        # group: '(' (yield_expr | named_expression) ')' | invalid_group
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self._tmp_99())
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_group := self.invalid_group())
        ):
            return [invalid_group]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def genexp(self) -> Optional[expr_ty]:
        # genexp: '(' named_expression ~ for_if_clauses ')' | invalid_comprehension
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.named_expression())
            and
            (cut := True)
            and
            (b := self.for_if_clauses())
            and
            (literal_1 := self.expect(')'))
        ):
            return _Py_GeneratorExp ( a , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_comprehension := self.invalid_comprehension())
        ):
            return [invalid_comprehension]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def set(self) -> Optional[expr_ty]:
        # set: '{' star_named_expressions '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (a := self.star_named_expressions())
            and
            (literal_1 := self.expect('}'))
        ):
            return _Py_Set ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def setcomp(self) -> Optional[expr_ty]:
        # setcomp: '{' named_expression ~ for_if_clauses '}' | invalid_comprehension
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (a := self.named_expression())
            and
            (cut := True)
            and
            (b := self.for_if_clauses())
            and
            (literal_1 := self.expect('}'))
        ):
            return _Py_SetComp ( a , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_comprehension := self.invalid_comprehension())
        ):
            return [invalid_comprehension]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dict(self) -> Optional[expr_ty]:
        # dict: '{' double_starred_kvpairs? '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (a := self.double_starred_kvpairs(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return _Py_Dict ( CHECK ( _PyPegen_get_keys ( p , a ) ) , CHECK ( _PyPegen_get_values ( p , a ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dictcomp(self) -> Optional[expr_ty]:
        # dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (a := self.kvpair())
            and
            (b := self.for_if_clauses())
            and
            (literal_1 := self.expect('}'))
        ):
            return _Py_DictComp ( a -> key , a -> value , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_dict_comprehension := self.invalid_dict_comprehension())
        ):
            return [invalid_dict_comprehension]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def double_starred_kvpairs(self) -> Optional[asdl_seq*]:
        # double_starred_kvpairs: ','.double_starred_kvpair+ ','?
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_100())
            and
            (opt := self.expect(','),)
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def double_starred_kvpair(self) -> Optional[KeyValuePair*]:
        # double_starred_kvpair: '**' bitwise_or | kvpair
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (a := self.bitwise_or())
        ):
            return _PyPegen_key_value_pair ( p , NULL , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (kvpair := self.kvpair())
        ):
            return [kvpair]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kvpair(self) -> Optional[KeyValuePair*]:
        # kvpair: expression ':' expression
        mark = self.mark()
        cut = False
        if (
            (a := self.expression())
            and
            (literal := self.expect(':'))
            and
            (b := self.expression())
        ):
            return _PyPegen_key_value_pair ( p , a , b )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def for_if_clauses(self) -> Optional[asdl_seq*]:
        # for_if_clauses: for_if_clause+
        mark = self.mark()
        cut = False
        if (
            (_loop1_102 := self._loop1_102())
        ):
            return [_loop1_102]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def for_if_clause(self) -> Optional[comprehension_ty]:
        # for_if_clause: ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | invalid_for_target
        mark = self.mark()
        cut = False
        if (
            (async := self.expect('ASYNC'))
            and
            (literal := self.expect('for'))
            and
            (a := self.star_targets())
            and
            (literal_1 := self.expect('in'))
            and
            (cut := True)
            and
            (b := self.disjunction())
            and
            (c := self._loop0_103(),)
        ):
            return CHECK_VERSION ( 6 , "Async comprehensions are" , _Py_comprehension ( a , b , c , 1 , p -> arena ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('for'))
            and
            (a := self.star_targets())
            and
            (literal_1 := self.expect('in'))
            and
            (cut := True)
            and
            (b := self.disjunction())
            and
            (c := self._loop0_104(),)
        ):
            return _Py_comprehension ( a , b , c , 0 , p -> arena )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_for_target := self.invalid_for_target())
        ):
            return [invalid_for_target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def yield_expr(self) -> Optional[expr_ty]:
        # yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('yield'))
            and
            (literal_1 := self.expect('from'))
            and
            (a := self.expression())
        ):
            return _Py_YieldFrom ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('yield'))
            and
            (a := self.star_expressions(),)
        ):
            return _Py_Yield ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def arguments(self) -> Optional[expr_ty]:
        # arguments: args ','? &')' | invalid_arguments
        mark = self.mark()
        cut = False
        if (
            (a := self.args())
            and
            (opt := self.expect(','),)
            and
            self.positive_lookahead(self.expect, ')')
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_arguments := self.invalid_arguments())
        ):
            return [invalid_arguments]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def args(self) -> Optional[expr_ty]:
        # args: ','.(starred_expression | named_expression !'=')+ [',' kwargs] | kwargs
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_105())
            and
            (b := self._tmp_107(),)
        ):
            return _PyPegen_collect_call_seqs ( p , a , b , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.kwargs())
        ):
            return _Py_Call ( _PyPegen_dummy_name ( p ) , CHECK_NULL_ALLOWED ( _PyPegen_seq_extract_starred_exprs ( p , a ) ) , CHECK_NULL_ALLOWED ( _PyPegen_seq_delete_starred_exprs ( p , a ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwargs(self) -> Optional[asdl_seq*]:
        # kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_108())
            and
            (literal := self.expect(','))
            and
            (b := self._gather_110())
        ):
            return _PyPegen_join_sequences ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_gather_112 := self._gather_112())
        ):
            return [_gather_112]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_gather_114 := self._gather_114())
        ):
            return [_gather_114]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def starred_expression(self) -> Optional[expr_ty]:
        # starred_expression: '*' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.expression())
        ):
            return _Py_Starred ( a , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwarg_or_starred(self) -> Optional[KeywordOrStarred*]:
        # kwarg_or_starred: NAME '=' expression | starred_expression | invalid_kwarg
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (literal := self.expect('='))
            and
            (b := self.expression())
        ):
            return _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.starred_expression())
        ):
            return _PyPegen_keyword_or_starred ( p , a , 0 )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_kwarg := self.invalid_kwarg())
        ):
            return [invalid_kwarg]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def kwarg_or_double_starred(self) -> Optional[KeywordOrStarred*]:
        # kwarg_or_double_starred: NAME '=' expression | '**' expression | invalid_kwarg
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (literal := self.expect('='))
            and
            (b := self.expression())
        ):
            return _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (a := self.expression())
        ):
            return _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( NULL , a , EXTRA ) ) , 1 )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_kwarg := self.invalid_kwarg())
        ):
            return [invalid_kwarg]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_targets(self) -> Optional[expr_ty]:
        # star_targets: star_target !',' | star_target ((',' star_target))* ','?
        mark = self.mark()
        cut = False
        if (
            (a := self.star_target())
            and
            self.negative_lookahead(self.expect, ',')
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.star_target())
            and
            (b := self._loop0_116(),)
            and
            (opt := self.expect(','),)
        ):
            return _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_targets_list_seq(self) -> Optional[asdl_seq*]:
        # star_targets_list_seq: ','.star_target+ ','?
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_117())
            and
            (opt := self.expect(','),)
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_targets_tuple_seq(self) -> Optional[asdl_seq*]:
        # star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
        mark = self.mark()
        cut = False
        if (
            (a := self.star_target())
            and
            (b := self._loop1_119())
            and
            (opt := self.expect(','),)
        ):
            return _PyPegen_seq_insert_in_front ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.star_target())
            and
            (literal := self.expect(','))
        ):
            return _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_target(self) -> Optional[expr_ty]:
        # star_target: '*' (!'*' star_target) | target_with_star_atom
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self._tmp_120())
        ):
            return _Py_Starred ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (target_with_star_atom := self.target_with_star_atom())
        ):
            return [target_with_star_atom]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def target_with_star_atom(self) -> Optional[expr_ty]:
        # target_with_star_atom: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom
        mark = self.mark()
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.slices())
            and
            (literal_1 := self.expect(']'))
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Subscript ( a , b , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_atom := self.star_atom())
        ):
            return [star_atom]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def star_atom(self) -> Optional[expr_ty]:
        # star_atom: NAME | '(' target_with_star_atom ')' | '(' star_targets_tuple_seq? ')' | '[' star_targets_list_seq? ']'
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
        ):
            return _PyPegen_set_expr_context ( p , a , Store )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.target_with_star_atom())
            and
            (literal_1 := self.expect(')'))
        ):
            return _PyPegen_set_expr_context ( p , a , Store )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.star_targets_tuple_seq(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return _Py_Tuple ( a , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (a := self.star_targets_list_seq(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return _Py_List ( a , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def single_target(self) -> Optional[expr_ty]:
        # single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
        mark = self.mark()
        cut = False
        if (
            (single_subscript_attribute_target := self.single_subscript_attribute_target())
        ):
            return [single_subscript_attribute_target]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.name())
        ):
            return _PyPegen_set_expr_context ( p , a , Store )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.single_target())
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def single_subscript_attribute_target(self) -> Optional[expr_ty]:
        # single_subscript_attribute_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead
        mark = self.mark()
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.slices())
            and
            (literal_1 := self.expect(']'))
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Subscript ( a , b , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def del_targets(self) -> Optional[asdl_seq*]:
        # del_targets: ','.del_target+ ','?
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_121())
            and
            (opt := self.expect(','),)
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def del_target(self) -> Optional[expr_ty]:
        # del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom
        mark = self.mark()
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Attribute ( a , b -> v . Name . id , Del , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.slices())
            and
            (literal_1 := self.expect(']'))
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Subscript ( a , b , Del , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (del_t_atom := self.del_t_atom())
        ):
            return [del_t_atom]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def del_t_atom(self) -> Optional[expr_ty]:
        # del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
        ):
            return _PyPegen_set_expr_context ( p , a , Del )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.del_target())
            and
            (literal_1 := self.expect(')'))
        ):
            return _PyPegen_set_expr_context ( p , a , Del )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.del_targets(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return _Py_Tuple ( a , Del , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (a := self.del_targets(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return _Py_List ( a , Del , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def targets(self) -> Optional[asdl_seq*]:
        # targets: ','.target+ ','?
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_123())
            and
            (opt := self.expect(','),)
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def target(self) -> Optional[expr_ty]:
        # target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | t_atom
        mark = self.mark()
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.slices())
            and
            (literal_1 := self.expect(']'))
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return _Py_Subscript ( a , b , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (t_atom := self.t_atom())
        ):
            return [t_atom]
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def t_primary(self) -> Optional[expr_ty]:
        # t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' arguments? ')' &t_lookahead | atom &t_lookahead
        mark = self.mark()
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return _Py_Attribute ( a , b -> v . Name . id , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.slices())
            and
            (literal_1 := self.expect(']'))
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return _Py_Subscript ( a , b , Load , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.t_primary())
            and
            (b := self.genexp())
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return _Py_Call ( a , CHECK ( _PyPegen_singleton_seq ( p , b ) ) , NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('('))
            and
            (b := self.arguments(),)
            and
            (literal_1 := self.expect(')'))
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return _Py_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.atom())
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def t_lookahead(self) -> Optional[Any]:
        # t_lookahead: '(' | '[' | '.'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('.'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def t_atom(self) -> Optional[expr_ty]:
        # t_atom: NAME | '(' target ')' | '(' targets? ')' | '[' targets? ']'
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
        ):
            return _PyPegen_set_expr_context ( p , a , Store )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.target())
            and
            (literal_1 := self.expect(')'))
        ):
            return _PyPegen_set_expr_context ( p , a , Store )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (b := self.targets(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return _Py_Tuple ( b , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('['))
            and
            (b := self.targets(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return _Py_List ( b , Store , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_arguments(self) -> Optional[Any]:
        # invalid_arguments: args ',' '*' | expression for_if_clauses ',' [args | expression for_if_clauses] | args for_if_clauses | args ',' expression for_if_clauses | args ',' args
        mark = self.mark()
        cut = False
        if (
            (args := self.args())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('*'))
        ):
            return RAISE_SYNTAX_ERROR ( "iterable argument unpacking follows keyword argument unpacking" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.expression())
            and
            (for_if_clauses := self.for_if_clauses())
            and
            (literal := self.expect(','))
            and
            (opt := self._tmp_125(),)
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "Generator expression must be parenthesized" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.args())
            and
            (for_if_clauses := self.for_if_clauses())
        ):
            return _PyPegen_nonparen_genexp_in_call ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (args := self.args())
            and
            (literal := self.expect(','))
            and
            (a := self.expression())
            and
            (for_if_clauses := self.for_if_clauses())
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "Generator expression must be parenthesized" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.args())
            and
            (literal := self.expect(','))
            and
            (args := self.args())
        ):
            return _PyPegen_arguments_parsing_error ( p , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_kwarg(self) -> Optional[Any]:
        # invalid_kwarg: !(NAME '=') expression '='
        mark = self.mark()
        cut = False
        if (
            self.negative_lookahead(self._tmp_126, )
            and
            (a := self.expression())
            and
            (b := self.expect('='))
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expression cannot contain assignment, perhaps you meant \"==\"?" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_named_expression(self) -> Optional[Any]:
        # invalid_named_expression: expression ':=' expression
        mark = self.mark()
        cut = False
        if (
            (a := self.expression())
            and
            (literal := self.expect(':='))
            and
            (expression := self.expression())
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot use assignment expressions with %s" , _PyPegen_get_expr_name ( a ) )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_assignment(self) -> Optional[Any]:
        # invalid_assignment: invalid_ann_assign_target ':' expression | star_named_expression ',' star_named_expressions* ':' expression | expression ':' expression | ((star_targets '='))* star_expressions '=' | ((star_targets '='))* yield_expr '=' | star_expressions augassign (yield_expr | star_expressions)
        mark = self.mark()
        cut = False
        if (
            (a := self.invalid_ann_assign_target())
            and
            (literal := self.expect(':'))
            and
            (expression := self.expression())
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "only single target (not %s) can be annotated" , _PyPegen_get_expr_name ( a ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.star_named_expression())
            and
            (literal := self.expect(','))
            and
            (_loop0_127 := self._loop0_127(),)
            and
            (literal_1 := self.expect(':'))
            and
            (expression := self.expression())
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "only single target (not tuple) can be annotated" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.expression())
            and
            (literal := self.expect(':'))
            and
            (expression := self.expression())
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "illegal target for annotation" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_loop0_128 := self._loop0_128(),)
            and
            (a := self.star_expressions())
            and
            (literal := self.expect('='))
        ):
            return RAISE_SYNTAX_ERROR_INVALID_TARGET ( STAR_TARGETS , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_loop0_129 := self._loop0_129(),)
            and
            (a := self.yield_expr())
            and
            (literal := self.expect('='))
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "assignment to yield expression not possible" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.star_expressions())
            and
            (augassign := self.augassign())
            and
            (_tmp_130 := self._tmp_130())
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "'%s' is an illegal expression for augmented assignment" , _PyPegen_get_expr_name ( a ) )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_ann_assign_target(self) -> Optional[expr_ty]:
        # invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
        mark = self.mark()
        cut = False
        if (
            (list := self.list())
        ):
            return [list]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (tuple := self.tuple())
        ):
            return [tuple]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.invalid_ann_assign_target())
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_del_stmt(self) -> Optional[Any]:
        # invalid_del_stmt: 'del' star_expressions
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('del'))
            and
            (a := self.star_expressions())
        ):
            return RAISE_SYNTAX_ERROR_INVALID_TARGET ( DEL_TARGETS , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_block(self) -> Optional[Any]:
        # invalid_block: NEWLINE !INDENT
        mark = self.mark()
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
            and
            self.negative_lookahead(self.expect, 'INDENT')
        ):
            return RAISE_INDENTATION_ERROR ( "expected an indented block" )
        self.reset(mark)
        if cut: return None
        return None

    @logger
    def invalid_primary(self) -> Optional[Any]:
        # invalid_primary: primary '{'
        mark = self.mark()
        cut = False
        if (
            (primary := self.primary())
            and
            (a := self.expect('{'))
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "invalid syntax" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_comprehension(self) -> Optional[Any]:
        # invalid_comprehension: ('[' | '(' | '{') starred_expression for_if_clauses
        mark = self.mark()
        cut = False
        if (
            (_tmp_131 := self._tmp_131())
            and
            (a := self.starred_expression())
            and
            (for_if_clauses := self.for_if_clauses())
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "iterable unpacking cannot be used in comprehension" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_dict_comprehension(self) -> Optional[Any]:
        # invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (a := self.expect('**'))
            and
            (bitwise_or := self.bitwise_or())
            and
            (for_if_clauses := self.for_if_clauses())
            and
            (literal_1 := self.expect('}'))
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "dict unpacking cannot be used in dict comprehension" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_parameters(self) -> Optional[Any]:
        # invalid_parameters: param_no_default* (slash_with_default | param_with_default+) param_no_default
        mark = self.mark()
        cut = False
        if (
            (_loop0_132 := self._loop0_132(),)
            and
            (_tmp_133 := self._tmp_133())
            and
            (param_no_default := self.param_no_default())
        ):
            return RAISE_SYNTAX_ERROR ( "non-default argument follows default argument" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_lambda_parameters(self) -> Optional[Any]:
        # invalid_lambda_parameters: lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default
        mark = self.mark()
        cut = False
        if (
            (_loop0_134 := self._loop0_134(),)
            and
            (_tmp_135 := self._tmp_135())
            and
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            return RAISE_SYNTAX_ERROR ( "non-default argument follows default argument" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_star_etc(self) -> Optional[Any]:
        # invalid_star_etc: '*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (_tmp_136 := self._tmp_136())
        ):
            return RAISE_SYNTAX_ERROR ( "named arguments must follow bare *" )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (literal_1 := self.expect(','))
            and
            (TYPE_COMMENT := self.TYPE_COMMENT())
        ):
            return RAISE_SYNTAX_ERROR ( "bare * has associated type comment" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_lambda_star_etc(self) -> Optional[Any]:
        # invalid_lambda_star_etc: '*' (':' | ',' (':' | '**'))
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (_tmp_137 := self._tmp_137())
        ):
            return RAISE_SYNTAX_ERROR ( "named arguments must follow bare *" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_double_type_comments(self) -> Optional[Any]:
        # invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
        mark = self.mark()
        cut = False
        if (
            (TYPE_COMMENT := self.TYPE_COMMENT())
            and
            (newline := self.expect('NEWLINE'))
            and
            (TYPE_COMMENT_1 := self.TYPE_COMMENT())
            and
            (newline_1 := self.expect('NEWLINE'))
            and
            (indent := self.expect('INDENT'))
        ):
            return RAISE_SYNTAX_ERROR ( "Cannot have two type comments on def" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_with_item(self) -> Optional[Any]:
        # invalid_with_item: expression 'as' expression
        mark = self.mark()
        cut = False
        if (
            (expression := self.expression())
            and
            (literal := self.expect('as'))
            and
            (a := self.expression())
        ):
            return RAISE_SYNTAX_ERROR_INVALID_TARGET ( STAR_TARGETS , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_for_target(self) -> Optional[Any]:
        # invalid_for_target: ASYNC? 'for' star_expressions
        mark = self.mark()
        cut = False
        if (
            (opt := self.expect('ASYNC'),)
            and
            (literal := self.expect('for'))
            and
            (a := self.star_expressions())
        ):
            return RAISE_SYNTAX_ERROR_INVALID_TARGET ( FOR_TARGETS , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_group(self) -> Optional[Any]:
        # invalid_group: '(' starred_expression ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.starred_expression())
            and
            (literal_1 := self.expect(')'))
        ):
            return RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "can't use starred expression here" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def invalid_import_from_targets(self) -> Optional[Any]:
        # invalid_import_from_targets: import_from_as_names ','
        mark = self.mark()
        cut = False
        if (
            (import_from_as_names := self.import_from_as_names())
            and
            (literal := self.expect(','))
        ):
            return RAISE_SYNTAX_ERROR ( "trailing comma not allowed without surrounding parentheses" )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: NEWLINE
        mark = self.mark()
        children = []
        cut = False
        while (
            (newline := self.expect('NEWLINE'))
        ):
            children.append([newline])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_2(self) -> Optional[Any]:
        # _loop0_2: NEWLINE
        mark = self.mark()
        children = []
        cut = False
        while (
            (newline := self.expect('NEWLINE'))
        ):
            children.append([newline])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: ',' expression
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_3(self) -> Optional[Any]:
        # _gather_3: expression _loop0_4
        mark = self.mark()
        cut = False
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_4())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_6(self) -> Optional[Any]:
        # _loop0_6: ',' expression
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_5(self) -> Optional[Any]:
        # _gather_5: expression _loop0_6
        mark = self.mark()
        cut = False
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_6())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_8(self) -> Optional[Any]:
        # _loop0_8: ',' expression
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_7(self) -> Optional[Any]:
        # _gather_7: expression _loop0_8
        mark = self.mark()
        cut = False
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_8())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: ',' expression
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.expression())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_9(self) -> Optional[Any]:
        # _gather_9: expression _loop0_10
        mark = self.mark()
        cut = False
        if (
            (elem := self.expression())
            is not None
            and
            (seq := self._loop0_10())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_11(self) -> Optional[Any]:
        # _loop1_11: statement
        mark = self.mark()
        children = []
        cut = False
        while (
            (statement := self.statement())
        ):
            children.append([statement])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_13(self) -> Optional[Any]:
        # _loop0_13: ';' small_stmt
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(';'))
            and
            (elem := self.small_stmt())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_12(self) -> Optional[Any]:
        # _gather_12: small_stmt _loop0_13
        mark = self.mark()
        cut = False
        if (
            (elem := self.small_stmt())
            is not None
            and
            (seq := self._loop0_13())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: 'import' | 'from'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('import'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('from'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: 'def' | '@' | ASYNC
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('def'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('@'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (async := self.expect('ASYNC'))
        ):
            return [async]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_16(self) -> Optional[Any]:
        # _tmp_16: 'class' | '@'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('class'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('@'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_17(self) -> Optional[Any]:
        # _tmp_17: 'with' | ASYNC
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('with'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (async := self.expect('ASYNC'))
        ):
            return [async]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_18(self) -> Optional[Any]:
        # _tmp_18: 'for' | ASYNC
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('for'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (async := self.expect('ASYNC'))
        ):
            return [async]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_19(self) -> Optional[Any]:
        # _tmp_19: '=' annotated_rhs
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('='))
            and
            (d := self.annotated_rhs())
        ):
            return d
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_20(self) -> Optional[Any]:
        # _tmp_20: '(' single_target ')' | single_subscript_attribute_target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (b := self.single_target())
            and
            (literal_1 := self.expect(')'))
        ):
            return b
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (single_subscript_attribute_target := self.single_subscript_attribute_target())
        ):
            return [single_subscript_attribute_target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_21(self) -> Optional[Any]:
        # _tmp_21: '=' annotated_rhs
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('='))
            and
            (d := self.annotated_rhs())
        ):
            return d
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_22(self) -> Optional[Any]:
        # _loop1_22: (star_targets '=')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_138 := self._tmp_138())
        ):
            children.append([_tmp_138])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_23(self) -> Optional[Any]:
        # _tmp_23: yield_expr | star_expressions
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_expressions := self.star_expressions())
        ):
            return [star_expressions]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_24(self) -> Optional[Any]:
        # _tmp_24: yield_expr | star_expressions
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_expressions := self.star_expressions())
        ):
            return [star_expressions]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_26(self) -> Optional[Any]:
        # _loop0_26: ',' NAME
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.name())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_25(self) -> Optional[Any]:
        # _gather_25: NAME _loop0_26
        mark = self.mark()
        cut = False
        if (
            (elem := self.name())
            is not None
            and
            (seq := self._loop0_26())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_28(self) -> Optional[Any]:
        # _loop0_28: ',' NAME
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.name())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_27(self) -> Optional[Any]:
        # _gather_27: NAME _loop0_28
        mark = self.mark()
        cut = False
        if (
            (elem := self.name())
            is not None
            and
            (seq := self._loop0_28())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_29(self) -> Optional[Any]:
        # _tmp_29: ',' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (z := self.expression())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_30(self) -> Optional[Any]:
        # _tmp_30: ';' | NEWLINE
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(';'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
        ):
            return [newline]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_31(self) -> Optional[Any]:
        # _loop0_31: ('.' | '...')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_139 := self._tmp_139())
        ):
            children.append([_tmp_139])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_32(self) -> Optional[Any]:
        # _loop1_32: ('.' | '...')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_140 := self._tmp_140())
        ):
            children.append([_tmp_140])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_34(self) -> Optional[Any]:
        # _loop0_34: ',' import_from_as_name
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.import_from_as_name())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_33(self) -> Optional[Any]:
        # _gather_33: import_from_as_name _loop0_34
        mark = self.mark()
        cut = False
        if (
            (elem := self.import_from_as_name())
            is not None
            and
            (seq := self._loop0_34())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_35(self) -> Optional[Any]:
        # _tmp_35: 'as' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (z := self.name())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_37(self) -> Optional[Any]:
        # _loop0_37: ',' dotted_as_name
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.dotted_as_name())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_36(self) -> Optional[Any]:
        # _gather_36: dotted_as_name _loop0_37
        mark = self.mark()
        cut = False
        if (
            (elem := self.dotted_as_name())
            is not None
            and
            (seq := self._loop0_37())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_38(self) -> Optional[Any]:
        # _tmp_38: 'as' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (z := self.name())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_40(self) -> Optional[Any]:
        # _loop0_40: ',' with_item
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.with_item())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_39(self) -> Optional[Any]:
        # _gather_39: with_item _loop0_40
        mark = self.mark()
        cut = False
        if (
            (elem := self.with_item())
            is not None
            and
            (seq := self._loop0_40())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_42(self) -> Optional[Any]:
        # _loop0_42: ',' with_item
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.with_item())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_41(self) -> Optional[Any]:
        # _gather_41: with_item _loop0_42
        mark = self.mark()
        cut = False
        if (
            (elem := self.with_item())
            is not None
            and
            (seq := self._loop0_42())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_44(self) -> Optional[Any]:
        # _loop0_44: ',' with_item
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.with_item())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_43(self) -> Optional[Any]:
        # _gather_43: with_item _loop0_44
        mark = self.mark()
        cut = False
        if (
            (elem := self.with_item())
            is not None
            and
            (seq := self._loop0_44())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_46(self) -> Optional[Any]:
        # _loop0_46: ',' with_item
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.with_item())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_45(self) -> Optional[Any]:
        # _gather_45: with_item _loop0_46
        mark = self.mark()
        cut = False
        if (
            (elem := self.with_item())
            is not None
            and
            (seq := self._loop0_46())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_47(self) -> Optional[Any]:
        # _tmp_47: ',' | ')' | ':'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect(')'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect(':'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_48(self) -> Optional[Any]:
        # _loop1_48: except_block
        mark = self.mark()
        children = []
        cut = False
        while (
            (except_block := self.except_block())
        ):
            children.append([except_block])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_49(self) -> Optional[Any]:
        # _tmp_49: 'as' NAME
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('as'))
            and
            (z := self.name())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_50(self) -> Optional[Any]:
        # _tmp_50: 'from' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (z := self.expression())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_51(self) -> Optional[Any]:
        # _tmp_51: '->' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('->'))
            and
            (z := self.expression())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_52(self) -> Optional[Any]:
        # _tmp_52: '->' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('->'))
            and
            (z := self.expression())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_53(self) -> Optional[Any]:
        # _tmp_53: NEWLINE INDENT
        mark = self.mark()
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
            and
            (indent := self.expect('INDENT'))
        ):
            return [newline, indent]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_54(self) -> Optional[Any]:
        # _loop0_54: param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append([param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_55(self) -> Optional[Any]:
        # _loop0_55: param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append([param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_56(self) -> Optional[Any]:
        # _loop0_56: param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append([param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_57(self) -> Optional[Any]:
        # _loop1_57: param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append([param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_58(self) -> Optional[Any]:
        # _loop0_58: param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append([param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_59(self) -> Optional[Any]:
        # _loop1_59: param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append([param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_60(self) -> Optional[Any]:
        # _loop1_60: param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append([param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_61(self) -> Optional[Any]:
        # _loop1_61: param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append([param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_62(self) -> Optional[Any]:
        # _loop0_62: param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append([param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_63(self) -> Optional[Any]:
        # _loop1_63: param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append([param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_64(self) -> Optional[Any]:
        # _loop0_64: param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append([param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_65(self) -> Optional[Any]:
        # _loop1_65: param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append([param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_66(self) -> Optional[Any]:
        # _loop0_66: param_maybe_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_maybe_default := self.param_maybe_default())
        ):
            children.append([param_maybe_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_67(self) -> Optional[Any]:
        # _loop1_67: param_maybe_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_maybe_default := self.param_maybe_default())
        ):
            children.append([param_maybe_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_68(self) -> Optional[Any]:
        # _loop1_68: ('@' named_expression NEWLINE)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_141 := self._tmp_141())
        ):
            children.append([_tmp_141])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_69(self) -> Optional[Any]:
        # _tmp_69: '(' arguments? ')'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (z := self.arguments(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_70(self) -> Optional[Any]:
        # _loop1_70: (',' star_expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_142 := self._tmp_142())
        ):
            children.append([_tmp_142])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_72(self) -> Optional[Any]:
        # _loop0_72: ',' star_named_expression
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.star_named_expression())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_71(self) -> Optional[Any]:
        # _gather_71: star_named_expression _loop0_72
        mark = self.mark()
        cut = False
        if (
            (elem := self.star_named_expression())
            is not None
            and
            (seq := self._loop0_72())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_73(self) -> Optional[Any]:
        # _loop1_73: (',' expression)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_143 := self._tmp_143())
        ):
            children.append([_tmp_143])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_74(self) -> Optional[Any]:
        # _loop0_74: lambda_param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            children.append([lambda_param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_75(self) -> Optional[Any]:
        # _loop0_75: lambda_param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_with_default := self.lambda_param_with_default())
        ):
            children.append([lambda_param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_76(self) -> Optional[Any]:
        # _loop0_76: lambda_param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_with_default := self.lambda_param_with_default())
        ):
            children.append([lambda_param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_77(self) -> Optional[Any]:
        # _loop1_77: lambda_param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            children.append([lambda_param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_78(self) -> Optional[Any]:
        # _loop0_78: lambda_param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_with_default := self.lambda_param_with_default())
        ):
            children.append([lambda_param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_79(self) -> Optional[Any]:
        # _loop1_79: lambda_param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_with_default := self.lambda_param_with_default())
        ):
            children.append([lambda_param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_80(self) -> Optional[Any]:
        # _loop1_80: lambda_param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            children.append([lambda_param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_81(self) -> Optional[Any]:
        # _loop1_81: lambda_param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            children.append([lambda_param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_82(self) -> Optional[Any]:
        # _loop0_82: lambda_param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            children.append([lambda_param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_83(self) -> Optional[Any]:
        # _loop1_83: lambda_param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_with_default := self.lambda_param_with_default())
        ):
            children.append([lambda_param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_84(self) -> Optional[Any]:
        # _loop0_84: lambda_param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            children.append([lambda_param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_85(self) -> Optional[Any]:
        # _loop1_85: lambda_param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_with_default := self.lambda_param_with_default())
        ):
            children.append([lambda_param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_86(self) -> Optional[Any]:
        # _loop0_86: lambda_param_maybe_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_maybe_default := self.lambda_param_maybe_default())
        ):
            children.append([lambda_param_maybe_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_87(self) -> Optional[Any]:
        # _loop1_87: lambda_param_maybe_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_maybe_default := self.lambda_param_maybe_default())
        ):
            children.append([lambda_param_maybe_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_88(self) -> Optional[Any]:
        # _loop1_88: ('or' conjunction)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_144 := self._tmp_144())
        ):
            children.append([_tmp_144])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_89(self) -> Optional[Any]:
        # _loop1_89: ('and' inversion)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_145 := self._tmp_145())
        ):
            children.append([_tmp_145])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_90(self) -> Optional[Any]:
        # _loop1_90: compare_op_bitwise_or_pair
        mark = self.mark()
        children = []
        cut = False
        while (
            (compare_op_bitwise_or_pair := self.compare_op_bitwise_or_pair())
        ):
            children.append([compare_op_bitwise_or_pair])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_92(self) -> Optional[Any]:
        # _loop0_92: ',' slice
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.slice())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_91(self) -> Optional[Any]:
        # _gather_91: slice _loop0_92
        mark = self.mark()
        cut = False
        if (
            (elem := self.slice())
            is not None
            and
            (seq := self._loop0_92())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_93(self) -> Optional[Any]:
        # _tmp_93: ':' expression?
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(':'))
            and
            (d := self.expression(),)
        ):
            return d
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_94(self) -> Optional[Any]:
        # _tmp_94: tuple | group | genexp
        mark = self.mark()
        cut = False
        if (
            (tuple := self.tuple())
        ):
            return [tuple]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (group := self.group())
        ):
            return [group]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (genexp := self.genexp())
        ):
            return [genexp]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_95(self) -> Optional[Any]:
        # _tmp_95: list | listcomp
        mark = self.mark()
        cut = False
        if (
            (list := self.list())
        ):
            return [list]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (listcomp := self.listcomp())
        ):
            return [listcomp]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_96(self) -> Optional[Any]:
        # _tmp_96: dict | set | dictcomp | setcomp
        mark = self.mark()
        cut = False
        if (
            (dict := self.dict())
        ):
            return [dict]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (set := self.set())
        ):
            return [set]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (dictcomp := self.dictcomp())
        ):
            return [dictcomp]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (setcomp := self.setcomp())
        ):
            return [setcomp]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_97(self) -> Optional[Any]:
        # _loop1_97: STRING
        mark = self.mark()
        children = []
        cut = False
        while (
            (string := self.string())
        ):
            children.append([string])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_98(self) -> Optional[Any]:
        # _tmp_98: star_named_expression ',' star_named_expressions?
        mark = self.mark()
        cut = False
        if (
            (y := self.star_named_expression())
            and
            (literal := self.expect(','))
            and
            (z := self.star_named_expressions(),)
        ):
            return _PyPegen_seq_insert_in_front ( p , y , z )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_99(self) -> Optional[Any]:
        # _tmp_99: yield_expr | named_expression
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (named_expression := self.named_expression())
        ):
            return [named_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_101(self) -> Optional[Any]:
        # _loop0_101: ',' double_starred_kvpair
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.double_starred_kvpair())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_100(self) -> Optional[Any]:
        # _gather_100: double_starred_kvpair _loop0_101
        mark = self.mark()
        cut = False
        if (
            (elem := self.double_starred_kvpair())
            is not None
            and
            (seq := self._loop0_101())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_102(self) -> Optional[Any]:
        # _loop1_102: for_if_clause
        mark = self.mark()
        children = []
        cut = False
        while (
            (for_if_clause := self.for_if_clause())
        ):
            children.append([for_if_clause])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_103(self) -> Optional[Any]:
        # _loop0_103: ('if' disjunction)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_146 := self._tmp_146())
        ):
            children.append([_tmp_146])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_104(self) -> Optional[Any]:
        # _loop0_104: ('if' disjunction)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_147 := self._tmp_147())
        ):
            children.append([_tmp_147])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_106(self) -> Optional[Any]:
        # _loop0_106: ',' (starred_expression | named_expression !'=')
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self._tmp_148())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_105(self) -> Optional[Any]:
        # _gather_105: (starred_expression | named_expression !'=') _loop0_106
        mark = self.mark()
        cut = False
        if (
            (elem := self._tmp_148())
            is not None
            and
            (seq := self._loop0_106())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_107(self) -> Optional[Any]:
        # _tmp_107: ',' kwargs
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (k := self.kwargs())
        ):
            return k
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_109(self) -> Optional[Any]:
        # _loop0_109: ',' kwarg_or_starred
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.kwarg_or_starred())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_108(self) -> Optional[Any]:
        # _gather_108: kwarg_or_starred _loop0_109
        mark = self.mark()
        cut = False
        if (
            (elem := self.kwarg_or_starred())
            is not None
            and
            (seq := self._loop0_109())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_111(self) -> Optional[Any]:
        # _loop0_111: ',' kwarg_or_double_starred
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.kwarg_or_double_starred())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_110(self) -> Optional[Any]:
        # _gather_110: kwarg_or_double_starred _loop0_111
        mark = self.mark()
        cut = False
        if (
            (elem := self.kwarg_or_double_starred())
            is not None
            and
            (seq := self._loop0_111())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_113(self) -> Optional[Any]:
        # _loop0_113: ',' kwarg_or_starred
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.kwarg_or_starred())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_112(self) -> Optional[Any]:
        # _gather_112: kwarg_or_starred _loop0_113
        mark = self.mark()
        cut = False
        if (
            (elem := self.kwarg_or_starred())
            is not None
            and
            (seq := self._loop0_113())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_115(self) -> Optional[Any]:
        # _loop0_115: ',' kwarg_or_double_starred
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.kwarg_or_double_starred())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_114(self) -> Optional[Any]:
        # _gather_114: kwarg_or_double_starred _loop0_115
        mark = self.mark()
        cut = False
        if (
            (elem := self.kwarg_or_double_starred())
            is not None
            and
            (seq := self._loop0_115())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_116(self) -> Optional[Any]:
        # _loop0_116: (',' star_target)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_149 := self._tmp_149())
        ):
            children.append([_tmp_149])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_118(self) -> Optional[Any]:
        # _loop0_118: ',' star_target
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.star_target())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_117(self) -> Optional[Any]:
        # _gather_117: star_target _loop0_118
        mark = self.mark()
        cut = False
        if (
            (elem := self.star_target())
            is not None
            and
            (seq := self._loop0_118())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_119(self) -> Optional[Any]:
        # _loop1_119: (',' star_target)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_150 := self._tmp_150())
        ):
            children.append([_tmp_150])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_120(self) -> Optional[Any]:
        # _tmp_120: !'*' star_target
        mark = self.mark()
        cut = False
        if (
            self.negative_lookahead(self.expect, '*')
            and
            (star_target := self.star_target())
        ):
            return [star_target]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_122(self) -> Optional[Any]:
        # _loop0_122: ',' del_target
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.del_target())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_121(self) -> Optional[Any]:
        # _gather_121: del_target _loop0_122
        mark = self.mark()
        cut = False
        if (
            (elem := self.del_target())
            is not None
            and
            (seq := self._loop0_122())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_124(self) -> Optional[Any]:
        # _loop0_124: ',' target
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect(','))
            and
            (elem := self.target())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_123(self) -> Optional[Any]:
        # _gather_123: target _loop0_124
        mark = self.mark()
        cut = False
        if (
            (elem := self.target())
            is not None
            and
            (seq := self._loop0_124())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_125(self) -> Optional[Any]:
        # _tmp_125: args | expression for_if_clauses
        mark = self.mark()
        cut = False
        if (
            (args := self.args())
        ):
            return [args]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (expression := self.expression())
            and
            (for_if_clauses := self.for_if_clauses())
        ):
            return [expression, for_if_clauses]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_126(self) -> Optional[Any]:
        # _tmp_126: NAME '='
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (literal := self.expect('='))
        ):
            return [name, literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_127(self) -> Optional[Any]:
        # _loop0_127: star_named_expressions
        mark = self.mark()
        children = []
        cut = False
        while (
            (star_named_expressions := self.star_named_expressions())
        ):
            children.append([star_named_expressions])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_128(self) -> Optional[Any]:
        # _loop0_128: (star_targets '=')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_151 := self._tmp_151())
        ):
            children.append([_tmp_151])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop0_129(self) -> Optional[Any]:
        # _loop0_129: (star_targets '=')
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_152 := self._tmp_152())
        ):
            children.append([_tmp_152])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_130(self) -> Optional[Any]:
        # _tmp_130: yield_expr | star_expressions
        mark = self.mark()
        cut = False
        if (
            (yield_expr := self.yield_expr())
        ):
            return [yield_expr]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (star_expressions := self.star_expressions())
        ):
            return [star_expressions]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_131(self) -> Optional[Any]:
        # _tmp_131: '[' | '(' | '{'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('['))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('('))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('{'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_132(self) -> Optional[Any]:
        # _loop0_132: param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_no_default := self.param_no_default())
        ):
            children.append([param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_133(self) -> Optional[Any]:
        # _tmp_133: slash_with_default | param_with_default+
        mark = self.mark()
        cut = False
        if (
            (slash_with_default := self.slash_with_default())
        ):
            return [slash_with_default]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_loop1_153 := self._loop1_153())
        ):
            return [_loop1_153]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_134(self) -> Optional[Any]:
        # _loop0_134: lambda_param_no_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_no_default := self.lambda_param_no_default())
        ):
            children.append([lambda_param_no_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_135(self) -> Optional[Any]:
        # _tmp_135: lambda_slash_with_default | lambda_param_with_default+
        mark = self.mark()
        cut = False
        if (
            (lambda_slash_with_default := self.lambda_slash_with_default())
        ):
            return [lambda_slash_with_default]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_loop1_154 := self._loop1_154())
        ):
            return [_loop1_154]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_136(self) -> Optional[Any]:
        # _tmp_136: ')' | ',' (')' | '**')
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(')'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect(','))
            and
            (_tmp_155 := self._tmp_155())
        ):
            return [literal, _tmp_155]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_137(self) -> Optional[Any]:
        # _tmp_137: ':' | ',' (':' | '**')
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(':'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect(','))
            and
            (_tmp_156 := self._tmp_156())
        ):
            return [literal, _tmp_156]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_138(self) -> Optional[Any]:
        # _tmp_138: star_targets '='
        mark = self.mark()
        cut = False
        if (
            (z := self.star_targets())
            and
            (literal := self.expect('='))
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_139(self) -> Optional[Any]:
        # _tmp_139: '.' | '...'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('...'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_140(self) -> Optional[Any]:
        # _tmp_140: '.' | '...'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('.'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('...'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_141(self) -> Optional[Any]:
        # _tmp_141: '@' named_expression NEWLINE
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('@'))
            and
            (f := self.named_expression())
            and
            (newline := self.expect('NEWLINE'))
        ):
            return f
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_142(self) -> Optional[Any]:
        # _tmp_142: ',' star_expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (c := self.star_expression())
        ):
            return c
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_143(self) -> Optional[Any]:
        # _tmp_143: ',' expression
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (c := self.expression())
        ):
            return c
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_144(self) -> Optional[Any]:
        # _tmp_144: 'or' conjunction
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('or'))
            and
            (c := self.conjunction())
        ):
            return c
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_145(self) -> Optional[Any]:
        # _tmp_145: 'and' inversion
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('and'))
            and
            (c := self.inversion())
        ):
            return c
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_146(self) -> Optional[Any]:
        # _tmp_146: 'if' disjunction
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (z := self.disjunction())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_147(self) -> Optional[Any]:
        # _tmp_147: 'if' disjunction
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (z := self.disjunction())
        ):
            return z
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_148(self) -> Optional[Any]:
        # _tmp_148: starred_expression | named_expression !'='
        mark = self.mark()
        cut = False
        if (
            (starred_expression := self.starred_expression())
        ):
            return [starred_expression]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (named_expression := self.named_expression())
            and
            self.negative_lookahead(self.expect, '=')
        ):
            return [named_expression]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_149(self) -> Optional[Any]:
        # _tmp_149: ',' star_target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (c := self.star_target())
        ):
            return c
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_150(self) -> Optional[Any]:
        # _tmp_150: ',' star_target
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(','))
            and
            (c := self.star_target())
        ):
            return c
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_151(self) -> Optional[Any]:
        # _tmp_151: star_targets '='
        mark = self.mark()
        cut = False
        if (
            (star_targets := self.star_targets())
            and
            (literal := self.expect('='))
        ):
            return [star_targets, literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_152(self) -> Optional[Any]:
        # _tmp_152: star_targets '='
        mark = self.mark()
        cut = False
        if (
            (star_targets := self.star_targets())
            and
            (literal := self.expect('='))
        ):
            return [star_targets, literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop1_153(self) -> Optional[Any]:
        # _loop1_153: param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (param_with_default := self.param_with_default())
        ):
            children.append([param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _loop1_154(self) -> Optional[Any]:
        # _loop1_154: lambda_param_with_default
        mark = self.mark()
        children = []
        cut = False
        while (
            (lambda_param_with_default := self.lambda_param_with_default())
        ):
            children.append([lambda_param_with_default])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_155(self) -> Optional[Any]:
        # _tmp_155: ')' | '**'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(')'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_156(self) -> Optional[Any]:
        # _tmp_156: ':' | '**'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect(':'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

void *
_PyPegen_parse(Parser *p)
{
    // Initialize keywords
    p->keywords = reserved_keywords;
    p->n_keyword_lists = n_keyword_lists;

    // Run parser
    void *result = NULL;
    if (p->start_rule == Py_file_input) {
        result = file_rule(p);
    } else if (p->start_rule == Py_single_input) {
        result = interactive_rule(p);
    } else if (p->start_rule == Py_eval_input) {
        result = eval_rule(p);
    } else if (p->start_rule == Py_func_type_input) {
        result = func_type_rule(p);
    } else if (p->start_rule == Py_fstring_input) {
        result = fstring_rule(p);
    }

    return result;
}

// The end
